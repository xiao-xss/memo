### 数据模型
#### 标准类型层级结构
以下为python内置类型，扩展模块可以定义更多的类型
- None
```
此类型只有一种取值，表示为空值，逻辑值为假，例如未显式指明返回值得函数将返回None
```
- NotImplemented
```
数值方法和丰富比较方法如未实现指定运算符表示的运算应返回此值，它的逻辑值为真
```
- Ellipsis
```
此类型只有一种取值，是一个具有此值的单独对象，此对象通过字面值...或内置名称Ellipsis访问，逻辑值为真
```
- numbers.Number
```
此类对象由数字字面值创建，并会被作为算术运算符和算术内置函数的返回结构，数字对象是不可变的，区分整型数、浮点数、复数
1. numbers.Integral
  此类对象表示数学中整数集合的成员（包含正数和负数）， 整数类型可细分为两种类型：
  - 整型（int）：表示任意大小的数字，仅受限于可用内存，在变换和掩码运算中以二进制表示
  - 布尔型（bool）：此类对象表示逻辑值False和True，是整型的子类型，两个布尔值在各种场合类似于整数0和1，只有在转换为字符
    串时分别返回字符串"False"和"True"
```
- 序列
```
此类对象表示以非负整数作为索引的有限有序集，内置函数len()返回一个序列的条目数，当一个序列的长度为n时，索引集包含数字
0,1,2...n-1，序列a的条目i用a[i]选择；序列还支持切片：a[i:j:k]，选择a中索引号为x的索引条目，x=i+n*k，n>=0且i<=x<j
序列可根据其可变性来加以区分：
- 不可变序列：对象一旦创建就不能改变，如果对象包含对其它对象的引用，其中的可变对象就是可以改变的，但是一个不可变对象所
              直接引用的对象集是不能改变的，以下类型属于不可变对象：
    i. 字符串：字符串是由Unicode码位值组成的序列，范围在U+0000-U+10FFFF之内的所有码位值都可以在字符串中使用
    i. 元组：一个元组中的条目可以是任意的python对象，包含两个或以上条目的元组由逗号分隔的表达式构成，只有一个条目的元组
       可通过在表达式后加一个逗号来构成（一个表达式本身不能创建为元组，因为圆括号里要用来设置表达式分组），一个空的元组
       可通过一对内容为空的圆括号创建
    i. 字节串：字节串是对象是一个不可变的数组，其中每个条目都是一个8位的字节，以取值范围0<=x<=256的整数表示
- 可变序列：可变序列在创建后仍可被改变，下标和切片标注可被用作赋值和删除语句的目标，目前有两种类型：
    i. 列表：列表中的条目可以是任意的python对象，列表由用方括号括起并由逗号分隔的多个表达式构成
    i. 字节数组：字节数组对象属于可变数组，可以通过内置的bytearray()构造器来创建
```
- 集合类型
```
此类对象表示由不重复且不可变对象组成的无序且有限的集合，因此不能通过下标来索引，但是可迭代的，由内置函数len()返回集合中
的条目数，常见的用处是快速成员检查，去除重复项以及进行交、并、差和对称差等数学运算。目前由两种内生集合类型：
- 集合：此类对象表示可变集合，可通过内置的set()构造器创建，并且创建后可通过方法修改，如add()
- 冻结集合：此类对象表示不可变集合，可通过内置的frozenset()构造器创建
```
- 映射
```
此类对象表示由任意索引集合所索引的对象的集合，通过下标a[k]可在映射a中选择索引为k的条目，内置函数len()返回映射中的条目，
目前只有一种内生映射类型
- 字典：此类对象表示由几乎任意值作为索引的有限个对象的集合，字典是可变的，可通过{...}标注来创建
```
- 可调用类型
```
此类型可以被应用于函数调用操作
- 用户定义函数：用户定义函数对象可通过函数定义来创建，它被调用时应附带一个参数列表，其中包含的条目应与函数所定义的形参列
表一致，函数特殊属性见下表：
  __doc__：        可写，该函数的文档字符串，没有则为None，不会被字类继承
  __name__：       可写，函数名称
  __qualname__：   可写，函数的qualified name
  __module__：     可写，函数所属模块的名称，没有则为None
  __defaults__：   可写，由具有默认值的参数的默认参数值组成的元组，如无任何参数具有默认值则为None
  __code__：       可写，表示编译后的函数体的代码对象
  __globals__：    只读，对存放该函数中全局变量的字典的引用--函数所属模块的全局命名空间
  __dict__：       可写，命名空间支持的函数属性
  __closure__：    只读，None或包含该函数可用变量的绑定的单元的元组
  __annotations__：可写，包含参数标注的字典，字典的键是参数名，如存在返回标注则为'return'
  __kwdefaults__： 可写，仅包含关键字参数默认值的字典

- 实例方法：实例方法用于结合类、类实例和任何可调用对象（通常为用户定义函数）
            - 特殊的只读属性有：
              __self__：  类实例对象本身
              __func__：  函数对象
              __doc__：   方法的文档，与__func__.__doc__作用相同
              __name__：  方法名称，与__func__.__name__作用相同
              __module__：方法所属模块名称，没有则为None
            方法还支持获取（但不能设置）下层函数对象的任意函数属性
            用户定义方法对象可在获取一个类的属性时被创建（也可能通过该类的一个实例）如果该属性为用户定义函数或类方法对象
            
            - 当通过从类或实例获取一个用户定义函数对象的方式创建一个实例方法对象时，类实例对象的__self__属性即为该实例，
              并会绑定方法对象，该新建方法的__func__属性就是原来的函数对象
            - 当通过从类或实例获取一个类方法对象的方式创建一个实例对象时，实例对象的__self__属性为该类本身，其__func__属
              性为类方法对应的下层函数对象
            - 当一个实例方法被调用时，会调用对应的下层函数（__func__），并将类实例（__self__）插入参数列表的开头，例如，
              当C是一个包含了f()函数定义的类，而x是C的一个实例，则调用x.f(1)就等同于调用C.f(x, 1)
            - 当一个实例方法对象是衍生自一个类方法对象时，保存在__self__中的“类实例”实际上会是该类本身，因此无论是调用
              x.f(1)还是C.f(1)都等同于调用C.f(x, 1)，其中f为对应的下层函数
- 生成器函数：一个使用yield语句的函数或方法被称作一个生成器函数，这样的函数在调用时总是返回一个可用执行函数体的迭代器对
              象，调用该迭代器的__next__()方法将会导致这个函数一直运行直到它使用yield语句提供了一个值为止
- 协程函数：使用async def定义的函数或方法被称为协程函数，函数被调用时会返回一个coroutine对象，它可能包含await表达式以及
            async with和async for语句
- 异步生成器函数：使用async def定义并且包含yield语句的函数
- 内置函数：内置函数对象是对于C函数的外部封装
- 内置方法：此类型实际上是内置函数的另一种形式，只不过还包含了一个传入C函数的对象作为隐式的额外参数
- 类：类是可调用的，此种对象通常是作为工厂来创建自身的实例
- 类实例：任意类的实例通过在所属类中定义__call__()方法即能成为可调用对象
```
- 模块
```
模块是python代码的基本组织单元，由导入系统创建，由import语句发起调用或者通过importlib.import_module()和内置的
__import()__等函数发起调用，模块对象具有由字典对象实现的命名空间，属性调用被转换为该字典中查找，模块对象不包含用于初始化
模块的代码对象
```
- 自定义类
```
自定义类一般通过类定义来创建，每个类都有通过一个字典对象实现的独立命名空间，类属性引用会被转化为在字典中查找，例如C.x会
转化为C.__dict__["x"]，当未在其中找到某个属性名称时，会继续在基类中查找，基类查找使用C3方法解析顺序，C3 MRO详情可查看文
档：https://www.python.org/download/releases/2.3/mro/，类属性赋值会更新字典，但不会更新基类字典
```
- 类实例
```
类实例可通过调用类对象创建，每个实例都有通过一个字典对象实现的独立命名空间，属性引用会首先在该字典中查找，当未发现某个
属性，而实例对应的类中有该属性时，则会继续在类属性中查找。属性赋值和删除会更新类实例的字典，但不会更新对应类的字典
```
- I/O对象（文件对象）
```
file object表示一个打开的文件，可使用多种方法创建文件对象：open()内置函数，os.popen()，os.fdopen()，socket.makefile()
```
- 内部类型
```
某些由解析器内部使用的类型也被暴漏给用户，它们的定义可能会随未来解析器版本的更新而变化
- 代码对象：代码对象表示编译为字节的可执行Python代码，或称bytecode，代码对象和函数对象的区别在于函数对象包含对函数全局
            对象（函数所属的模块）的显式引用，而代码对象不包含上下文，而且默认参数值会存放于函数对象而不是代码对象内，
            与函数对象不同，代码对象不可变，也不包含对可变对象的引用，不论是直接的还是间接的
- 帧对象：帧对象表示执行帧，它们可能出现在回溯对象中，还会被传递给注册跟踪函数
- 回溯对象：表示一个异常的栈跟踪记录，当异常发生时会隐式创建一个回溯对象，也可通过types.TracebackType显式的创建
- 切片对象：切片对象用来表示__getitem__()方法得到的切片，该对象也可用内置的slice()函数来创建
- 静态方法对象：静态方法对象提供了一种避免上文所述将函数对象转换为方法对象的方式，静态方法对象为对任意其他对象的封装，
                通常用来封装用户定义方法对象。当从类或类实例获取一个静态方法对象时，实际返回的对象是封装的对象，它不会
                被进一步转换。静态方法对象自身不是可调用的，但它们所封装的对象通常都是可调用的。静态方法对象可通过内置的
                 staticmethod() 构造器来创建
- 类方法对象：类方法对象和静态方法一样是对其他对象的封装，会改变从类或类实例获取该对象的方式。类方法对象在此类获取操作中
              的行为已在上文 "用户定义方法" 一节中描述。类方法对象可通过内置的 classmethod() 构造器来创建
```
#### 特殊方法名称
```
一个类可以通过定义具有特殊名称的方法来实现由特殊语法所引发的特殊操作，将一个特殊方法设为None，表示对应的操作不可以
```
1. 基本定制
2. 自定义属性访问
3. 自定义类创建
4. 自定义实例及字类检查
5. 模拟泛型类型
6. 模拟可调用对象
7. 模拟容器类型
8. 模拟数字类型
9. with语句上下文管理
10. 特殊方法查找
#### 协程
1. 可等待对象
2. 协程对象
3. 异步迭代器
4. 异步上下文管理器
- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 
### 执行模型